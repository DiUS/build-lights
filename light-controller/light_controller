#!/usr/bin/python
""" Build light controller """

import os
current_dir = os.path.dirname(os.path.realpath(__file__))
import sys
sys.path.append(current_dir)

import signal
import getopt
import importlib

from lib import daemonize
from lib import logger
from lib import list_utils
from config import json_config

default_config_file = 'config.json'
light = None
dlogger = None

def _write_pid(filename):
    global dlogger

    try:
        pidfile = open(filename, "w")
        pidfile.write("%d\n" % os.getpid())
        pidfile.close()
    except IOError, e:
        dlogger.log("ERROR: unable to write pid file %s: %s", filename, str(e))

def _unlink_pid(filename):
    try:
        os.unlink(filename)
    except:
        pass

def _handle_signals(signum, stack):
    global light
    if signum == signal.SIGTERM or signum == signal.SIGINT:
        if light is not None:
            light.stop()


def print_usage(prog_cmd):
    print "Usage: %s [options]" % prog_cmd
    print "Options:"
    print "-b           --daemonize         Run in the background."
    print "-l           --syslog            Log output to syslog."
    print "-c <file>    --config <file>     Config file, default \"%s\"." % default_config_file
    print "-h           --help              Print this help page."



def run():

    global light
    global dlogger

    background = False
    forcesyslog = False
    config_file = default_config_file
    dlogger = logger.Logger(os.path.basename(sys.argv[0]))

    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "hblc:", ["help", "daemonize", "syslog", "config="])
    except getopt.error, why:
        print "Error: getopt error: %s" % (why)
        print_usage(sys.argv[0])
        sys.exit(-1)

    try:
        for opt in opts:
            if opt[0] == "-h" or opt[0] == "--help":
                print_usage(sys.argv[0])
                sys.exit(1)
            if opt[0] == "-b" or opt[0] == "--daemonize":
                background = True
                continue
            if opt[0] == "-l" or opt[0] == "--syslog":
                forcesyslog = True
                continue
            if opt[0] == "-c" or opt[0] == "--config":
                config_file = opt[1]
                continue
            print_usage(sys.argv[0])
            sys.exit(-1)
    except ValueError, why:
        print "Error: bad parameter \"%s\" for option %s: %s" % (opt[1], opt[0], why)
        print_usage(sys.argv[0])
        sys.exit(-1)



    if forcesyslog:
        logger.Logger.use_syslog = True

    if background:
        logger.Logger.use_syslog = True
        daemonize.createDaemon()

    signal.signal(signal.SIGTERM, _handle_signals)
    signal.signal(signal.SIGINT, _handle_signals)


    try:
        if not os.path.isfile(config_file):
            dlogger.log("ERROR: config file %s not found.", config_file)
            sys.exit(-1)

        conf = json_config.JsonConfig(config_file)
        api_conf = conf.get_api_config()
        light_conf = conf.get_light_config()
        jobs = conf.get_jobs()
        poll_interval_seconds = 3

        from lights import job2ledstrip

        light_type = light_conf['type']
        dlogger.log("Light type is " + light_type)

        try:
            kwargs = { x:light_conf[x] for x in ['num_leds', 'spidev', 'simulate_mode'] if x in light_conf }
            light = importlib.import_module('lights.' + light_type).Strand(**kwargs)
        except ImportError:
            raise json_config.ConfigError(str(light_type) + ' light type not supported')

        if api_conf.has_key('pollrate_s'):
            if api_conf['pollrate_s'] != 0:
                poll_interval_seconds = api_conf['pollrate_s']
                dlogger.log("Polling API once every %s seconds.", str(poll_interval_seconds))
            else:
                poll_interval_seconds = None
                dlogger.log("NOT Polling API.")

    except Exception, e:
        logger.print_trace(e)
        sys.exit(-1)

    pidfilename = "/var/run/%s.pid" % os.path.basename(sys.argv[0])
    _write_pid(pidfilename)

    dlogger.log("Starting light controller")
    translator = job2ledstrip.Job2LedStrip(jobs, light)
    try:
        if api_conf['type'] == 'jenkins':
            from datasource.jenkins_source import JenkinsSource
            source = JenkinsSource(api_conf['url'])
        elif api_conf['type'] == 'circleci':
            from datasource.circleci_source import CircleCISource
            source = CircleCISource(api_conf['api_token'], api_conf['username'])
        else:
            raise json_config.ConfigError(str(api_conf['type']) + ' API type not supported')

        # start the light driver
        light.daemon = True
        light.start()

        while True:
            for job in jobs:
                status = source.project_status(job)
                translator.update(job, status)
            light.join(poll_interval_seconds)
            if not light.isAlive():
                break
    except Exception, e:
        logger.print_trace(e)

    _unlink_pid(pidfilename)
    dlogger.log("Terminated light controller")

if __name__ == "__main__":
    run()
