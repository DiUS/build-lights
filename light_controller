#!/usr/bin/python
""" Build light controller """

import sys
sys.path.append("./lib")
sys.path.append("./lights")
sys.path.append("./monitors")
sys.path.append("./pollers")
sys.path.append("./config")

import signal
import os
import getopt

import daemonize
import logger
import json_config




default_config_file = 'config.json'
light = None


def _handle_signals(signum, stack):
    global light
    if signum == signal.SIGTERM or signum == signal.SIGINT:
        if light is not None:
            light.stop()


def print_usage(prog_cmd):
    print "Usage: %s [options]" % prog_cmd
    print "Options:"
    print "-b           --daemonize         Run in the background."
    print "-l           --syslog            Log output to syslog."
    print "-c <file>    --config <file>     Config file, default \"%s\"." % default_config_file
    print "-h           --help              Print this help page."



def run():

    global light

    background = False
    forcesyslog = False
    config_file = default_config_file
    dlogger = logger.Logger(os.path.basename(sys.argv[0]))

    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "hblc:s:d:u:", ["help", "daemonize", "syslog", "config="])
    except getopt.error, why:
        print "Error: getopt error: %s" % (why)
        print_usage(sys.argv[0])
        sys.exit(-1)

    try:
        for opt in opts:
            if opt[0] == "-h" or opt[0] == "--help":
                print_usage(sys.argv[0])
                sys.exit(1)
            if opt[0] == "-b" or opt[0] == "--daemonize":
                background = True
                continue
            if opt[0] == "-l" or opt[0] == "--syslog":
                forcesyslog = True
                continue
            if opt[0] == "-c" or opt[0] == "--config":
                config_file = opt[1]
                continue
            print_usage(sys.argv[0])
            sys.exit(-1)
    except ValueError, why:
        print "Error: bad parameter \"%s\" for option %s: %s" % (opt[1], opt[0], why)
        print_usage(sys.argv[0])
        sys.exit(-1)



    if forcesyslog:
        logger.Logger.use_syslog = True

    if background:
        logger.Logger.use_syslog = True
        daemonize.createDaemon()



    try:
        if not os.path.isfile(config_file):
            dlogger.log("ERROR: config file %s not found.", config_file)
            sys.exit(-1)

        conf = json_config.JsonConfig(config_file)
        api_conf = conf.get_api_config()
        light_conf = conf.get_light_config()
        jobs = conf.get_jobs()


        if light_conf['type'] == 'strand':
            import ledstrip
            import job2ledstrip
            kwargs = {}
            if light_conf.has_key('num_leds'):
                kwargs['num_leds'] = light_conf['num_leds']
            if light_conf.has_key('spidev'):
                kwargs['spidev'] = light_conf['spidev']
            if light_conf.has_key('simulate_mode'):
                kwargs['simulate_mode'] = light_conf['simulate_mode']
            light = ledstrip.Strand(**kwargs)
        else:
            raise json_config.ConfigError(str(light_conf['strand']) + ' light type not supported')

        if api_conf['type'] == 'jenkins_direct':
            import jenkins_monitor
            import jenkins_poller
        else:
            raise ConfigError(str(api_conf['type']) + ' API type not supported')

    except Exception, e:
        logger.print_trace(e)
        sys.exit(-1)



    # write pid file
    pidfilename = "/var/run/%s.pid" % os.path.basename(sys.argv[0])
    try:
        pidfile = open(pidfilename, "w")
        pidfile.write("%d\n" % os.getpid())
        pidfile.close()
    except IOError, e:
        dlogger.log("ERROR: unable to write pid file %s: %s", pidfilename, str(e))

    dlogger.log("Starting light controller")
    try:
        translator = job2ledstrip.Job2LedStrip(jobs, light)

        if api_conf['type'] == 'jenkins_direct':
            monitor = jenkins_monitor.JenkinsMonitor(jobs, translator)
            poller = jenkins_poller.JenkinsPoller(api_conf['url'], monitor)

        # start the light driver
        light.daemon = True
        light.start()

        while True:
            poller.poll()
            light.join(3)
            if not light.isAlive():
                break
    except Exception, e:
        logger.print_trace(e)

    try:
        os.unlink(pidfilename)
    except:
        pass

    dlogger.log("Terminated light controller")


if __name__ == "__main__":
    run()
