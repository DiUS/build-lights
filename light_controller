#!/usr/bin/python
""" Build light controller """

import sys
sys.path.append("./lib")
sys.path.append("./lights")
sys.path.append("./monitors")
sys.path.append("./pollers")
sys.path.append("./config")

import signal
import os
import getopt

import daemonize
import error
import logger
import json_config


class Error(error.Generic):
    """Base class for light controller module exceptions"""
    pass

class ConfigError(Error):
    """Config error"""
    pass


light = None


def _handle_signals(signum, stack):
    global light
    if signum == signal.SIGTERM or signum == signal.SIGINT:
        if light is not None:
            light.stop()


def print_usage(prog_cmd):
    print "Usage: %s [options]" % prog_cmd
    print "Options:"
    print "-b           --daemonize         Run in the background."
    print "-l           --syslog            Log output to syslog."
    print "-h           --help              Print this help page."



def run():

    global light

    background = False
    forcesyslog = False
    dlogger = logger.Logger('LightController')

    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "hblc:s:d:u:", ["help", "daemonize", "syslog", "cacert=", "sslcert=", "devid=", "url="])
    except getopt.error, why:
        print "Error: getopt error: %s" % (why)
        print_usage(sys.argv[0])
        sys.exit(-1)

    try:
        for opt in opts:
            if opt[0] == "-h" or opt[0] == "--help":
                print_usage(sys.argv[0])
                sys.exit(1)
            if opt[0] == "-b" or opt[0] == "--daemonize":
                background = True
                continue
            if opt[0] == "-l" or opt[0] == "--syslog":
                forcesyslog = True
                continue
            print_usage(sys.argv[0])
            sys.exit(-1)
    except ValueError, why:
        print "Error: bad parameter \"%s\" for option %s: %s" % (opt[1], opt[0], why)
        print_usage(sys.argv[0])
        sys.exit(-1)



    # TODO: specify config file from cli args
    conf = json_config.JsonConfig()

    api_conf = conf.get_api_config()
    light_conf = conf.get_light_config()
    jobs = conf.get_jobs()

    if light_conf['type'] == 'strand':
        import ledstrip
        import job2ledstrip
        light = ledstrip.Strand(num_leds=light_conf['num_leds'], spidev=light_conf['spidev'])
    else:
        raise ConfigError(str(light_conf['strand']) + ' light type not supported')

    if api_conf['type'] == 'jenkins_direct':
        import jenkins_monitor
        import jenkins_poller
    else:
        raise ConfigError(str(api_conf['type']) + ' API type not supported')



    if forcesyslog:
        logger.Logger.use_syslog = True

    if background:
        logger.Logger.use_syslog = True
        daemonize.createDaemon()

    # write pid file
    pidfilename = "/var/run/%s.pid" % os.path.basename(sys.argv[0])
    try:
        pidfile = open(pidfilename, "w")
        pidfile.write("%d\n" % os.getpid())
        pidfile.close()
    except IOError, e:
        dlogger.log("Error: unable to write pid file %s: %s", pidfilename, str(e))

    dlogger.log("Starting light controller")
    try:
        translator = job2ledstrip.Job2LedStrip(jobs, light)

        if api_conf['type'] == 'jenkins_direct':
            monitor = jenkins_monitor.JenkinsMonitor(jobs, translator)
            poller = jenkins_poller.JenkinsPoller(api_conf['url'], monitor)

        # start the light driver
        light.daemon = True
        light.start()

        while True:
            poller.poll()
            light.join(3)
            if not light.isAlive():
                break
    except Exception, e:
        logger.print_trace(e)

    try:
        os.unlink(pidfilename)
    except:
        pass

    dlogger.log("Terminated light controller")


if __name__ == "__main__":
    run()
